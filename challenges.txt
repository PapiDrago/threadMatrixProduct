P1: Ho usato Thread per implementare il prodotto riga-colonna.
Tutto cio' funziona. Si noti che tutti questi thread accedono
alla stessa risorsa in modo non sincrinizzato. Tuttavia non c'e'
nessun pericolo di incosistenza dei dati perche' le scritture
avvengono a indirizzi di memoria diversi (dello stesso spazio).
Il problema nasce nel momento in cui voglio inserire una lettura
della matrice a cavallo delle operazioni di prodotto.
Ho dato il compito di continuare a leggere la matrice a un altro
thread. Putroppo questo thread continuava a stampare la matrice
come se non fosse stata oggetto di nessuna modifica.
Questo accade perche' non e' stata fissata nessuna happens-before
relationships, ovvero non c'e' nessuna garanzia che le scritture
di uno statement siano visibili da un altro statement.

Ho risolto (si fa per dire) il problema mettendo in un blocco
synchronized la scrittura del risultato del prodotto riga-colonna
nella corrispondente entry della matrice; e mettendo
in un blocco synchronized la lettura della matrice. Tuttavia
poiche' non decido io l'ordine di esecuzione dei thread non e'
detto che la stampa avvenga dopo la scrittura di un entry.
Può capitare se sono sfortunato che ci sia una stampa della
matrice nulla e nella successiva tutto il risultato.
Puo' capitare addirittura di avere due stampe consecutive
dello stesso stato della matrice.

Ho provato a implementare delle stampe più granulari dello stato
della matrice usando un wait nel blocco synchronized e un
notify nel blocco synchronized del thread di stampa.
Il risultato non è stato soddisfacente perche' non e'
detto che dopo il notify vada il thread che prima era in attesa.
Il più delle volte è avvenuta una situazione di deadlock
in cui i thread dei prodotti avevano finito e il thread della
stampa è stato messo in esecuzione dopo gli altri e dunque è
andato in uno stato di attesa indefinita.

La classe 'AtomicBoolean' modella il concetto di variabile
booleana che puo' essere scritta/letta in un'operazione atomica.
Questa si e' resa necessaria per far terminare il thread
di stampa nel momento in cui tutti i thread dei prodotti
sono terminati. In generale serve per leggere dati
consistenti.
Dichiarare una variabile 'volatile' fa si che le scritture 
e le letture di essa siano operazioni atomiche.

Wait è un metodo dell'oggetto. Deve essere invocato
sull'oggetto di cui il thread possiede il lock e deve essere
invocato quando si ha il lock dell'oggetto, quindi farà parte
di un blocco (o metodo) synchronized.

In realtà la stampa della matrice funziona anche se non è in
un blocco synchronized.
In realtà la stampa della matrice funziona anche se non è, la
sua reference, dichiarata volatile nella classe del prodotto.
In realtà funziona anche in modo non sincronizzato: P1 non
sussisteva. Ovviamente se non sincronizzo le operazioni di 
stampa e di scrittura del prodotto, non c'e' garanzia che 
quanto stampato rispecchi lo stato corrente della matrice. 
